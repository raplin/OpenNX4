# coding=utf-8
"""
//////////////////////////////////////////////////////////////////////////////////
// OpenNX4 - Open source firmware for Barco NX4 tiles
// Company: Bohemian Bits
// Engineer: Richard Aplin (Twitter: @DrTune)
// Copyright (C) 2017 Richard Aplin
// Released under the Attribution-NonCommercial 2.0 Generic (CC BY-NC 2.0)
// You may not use this code or a derived work for commercial purposes unless you have a commercial license, contact drtune@gmail.com
//////////////////////////////////////////////////////////////////////////////////

This is a swiss-army-knife that talks to the NX4 firmware over UART (or SPI or...)

Notably it can generate verilog simulation input files (pass 'test' on cmdline)
as well as taking to a real device

Works on linux, should work fine on windows (change com port name to e.g. "COM6")

Currently only works on UART, e.g. with an FTDI dongle. 

I suggest you use 100-ohm resistor on the TX (input to NX4) pin


"""
from __future__ import print_function, division

import random
import sys
import threading
import time

import serial
from PIL.XVThumbImagePlugin import b

from NX4CommsHeaderReader import NX4
from VideoSource import VideoSource

try:  # python3
    import queue
except ImportError:  # python2
    import Queue as queue

try:
    import pygame  # for loading images, not vital

    pygame.init()
    HAS_PYGAME = True
except ImportError:
    HAS_PYGAME = False

# DOT_CORRECT_DEFAULT=1 #5  #6 bit value

DEFAULT_COM_PORT = "/dev/ttyUSB0"  # use a COM if on windows

BAUD = 115200 << NX4.DEFAULT_BAUD_MULTIPLIER
print("{} baud".format(BAUD))
BREAK_TIME_BITS = 15

SIM_SCRIPT_FOLDER = "test_scripts_gen/"
SIM_TEST_FILE = "openNX4_toplevel_test_autogen"

random.seed(0)


class ReadTimeout(Exception):
    pass


# /////////////////////////////////////////////////
class IODevice(object):
    TIME_SCALE = 1.0
    SIMULATION = False

    def __init__(self):
        self.prefixLength = 1  # default in the hw to a 1 byte length prefix
        self.sendFlush = True
        self.stop = False

    def sleep(self, t):
        time.sleep(t * self.TIME_SCALE)

    def sendMessage(self, messageBytes):
        if not isinstance(messageBytes, str):
            messageBytes = "".join([chr(d) for d in messageBytes])
        self.startMessage()
        self.sendMessage(b)
        self.stopMessage()

    def addPrefix(self, b):
        l = len(b)
        if l == 0:
            raise Exception("Zero length message")
        l -= 1
        if self.prefixLength == 1:
            if l > 255:
                raise Exception("Message too long for this mode ({:d}) use larger lengthPrefix".format(l))
            b = chr(l & 0xff) + b
        elif self.prefixLength == 2:
            if l > 65535:
                raise Exception("Message too long for this mode ({:d})".format(l))
            b = chr(l >> 8) + chr(l & 0xff) + b
        return b

    def setSimulationName(self, name):
        self.simulationName = name

    def setLengthPrefix(self, prefixLength):
        self.prefixLength = prefixLength

    def sendBreak(self):
        pass

    def flushComms(self):
        self.sendFlush = False
        self.sendBreak()


# //////////////////////////////////////////////////////

class VerilogTestGenBase(IODevice):
    TIME_SCALE = 0.0001
    SIMULATION = True
    MAX_SIM_WRITES = 5000

    PREFIX = ""
    SUFFIX = ""

    def __init__(self, deviceParams):
        IODevice.__init__(self)
        self.simulationName = "unknown"  # this is not known till after init and is written in
        self.deviceParams = deviceParams

    def sleep(self, t):
        # todo! insert delay into simulation
        pass

    def openTransport(self):
        self.tests = []

    def closeTransport(self):
        fileName = "{}{}.v".format(self.SIMULATION_NAME_PREFIX, self.simulationName)
        filePath = SIM_SCRIPT_FOLDER + fileName
        with open(filePath, "w") as f:
            f.write(self.PREFIX)
            tests = "\n".join(self.tests)
            f.write("\n// *** AUTOGENERATED DO NOT EDIT : {} *** \n\n".format(filePath))
            f.write(tests)
            f.write(self.SUFFIX)
            print("\n\n\n\n\n{}".format(tests))
        print("Wrote ISE test script {}".format(filePath))

    def writeSim(self, test):
        self.tests += [test]
        if len(self.tests) == self.MAX_SIM_WRITES:
            self.stop = True


# /////////////////////////////////////////////

class SPISimulation(VerilogTestGenBase):
    SIMULATION_NAME_PREFIX = "spi_"
    PREFIX = """
always begin:test
integer i;
`define SPICLK2 100
`define mosi mosi
`define cs cs
`define sck sck
#400 cs=1;
    """

    SUFFIX = """
//end of test
end
"""
    WIDTH = 8

    def assertCS(self, active):
        self.writeSim("#`SPICLK2 `cs={:d};".format(1 - active))

    def mosiSPIByte(self, value):
        self.writeSim("for(i={:d};i>=0;i=i-1) begin".format(self.WIDTH - 1))
        self.writeSim("#`SPICLK2 `mosi=({:d} >> i)&1; `sck=1; #`SPICLK2 `sck=0; ".format(value))
        self.writeSim("end")

    def misoSPIByte(self, value):
        self.writeSim("tx_data=8'd{:d}; tx_data_strobe=1; ".format(value))

    def mosiSPI(self, data):
        for d in data:
            self.mosiSPIByte(ord(d))

    def misoSPI(self, data):
        for d in data:
            self.misoSPIByte(ord(d))

    def startMessage(self):
        if self.prefixLength == 0:
            self.assertCS(1)

    def stopMessage(self):
        self.assertCS(0)

    def sendMessage(self, bytes):
        # self.misoSPI(chr(0x8a))
        bytes = self.addPrefix(bytes)
        self.mosiSPI(bytes)


# /////////////////////////////////////////////


class UARTSimulation(VerilogTestGenBase):
    SIMULATION_NAME_PREFIX = "uart_"

    PREFIX = """
always begin:test
integer i;
`define UARTCLK {:d}
`define BREAKCLK {:d}
`define rx rx
`define cs cs
`define sck sck
#400 rx=1;
    """.format(1000000000 // BAUD, (1000000000 // BAUD) * BREAK_TIME_BITS)

    SUFFIX = """
//end of test
end
"""
    WIDTH = 8

    def sendBreak(self):
        self.writeSim("#`UARTCLK `rx=0; //send break")
        self.writeSim("#`BREAKCLK `rx=1; ")

    def uartByte(self, value):
        # start bit
        self.writeSim("#`UARTCLK `rx=0; ")
        # data
        self.writeSim("for(i=0;i<{:d};i=i+1) begin\t// send 0x{:02x}".format(self.WIDTH, value))
        self.writeSim("#`UARTCLK `rx=({:d} >> i)&1; ".format(value))
        self.writeSim("end")
        # stop bit
        self.writeSim("#`UARTCLK `rx=1; ")

    def startMessage(self):
        if self.prefixLength == 0 or self.sendFlush:
            self.flushComms()

    def stopMessage(self):
        pass

    def sendMessage(self, bytes):
        if not isinstance(bytes, str):
            bytes = "".join([chr(d) for d in bytes])
        bytes = self.addPrefix(bytes)
        self.writeRaw(bytes)

    def writeRaw(self, bytes):
        for b in bytes:
            self.uartByte(ord(b))

    def readBytes(self, length):
        return [0 for n in range(length)]

    def skipBytes(self, length):
        pass


# /////////////////////////////////////////////


class UART(IODevice):
    TIME_SCALE = 1.0
    DEBUG = False

    def __init__(self, deviceParams={"port": "/dev/ttyUSB0"}):
        IODevice.__init__(self)
        self.ttyDevice = deviceParams["port"]
        self.baud = BAUD
        self.stop = False
        self.flushReply()

    def openTransport(self):
        self.serial = serial.Serial(self.ttyDevice, self.baud, stopbits=2, timeout=0.2, xonxoff=0, rtscts=False, dsrdtr=False)
        self.serial.flush()
        self.listener = threading.Thread(target=self.listen)
        self.listener.daemon = True
        self.listener.start()

    def closeTransport(self):
        self.stop = True
        time.sleep(1)
        self.serial.close()
        # todo properly

    def listen(self):
        totalRx = 0
        self.skipByteCount = 0
        while True:
            data = self.serial.read(1)
            if self.stop:
                return
            if len(data):
                totalRx += len(data)
                for d in data:
                    if self.skipByteCount:
                        self.skipByteCount -= 1
                    else:
                        self.readQ.put(ord(d))
                    if self.DEBUG:
                        print("<{:02x}".format(ord(d)), end=' ')
                if self.DEBUG:
                    print("")
                # print("\t>", end=' ')
                # for d in data:
                #     print("{:02x}".format(ord(d)), end=' ')
                # print("")

                # print(">{}<".format(totalRx))
                # if data:
                # print(("0x%02x" % ord(data),data))

    def sendBreak(self):
        self.serial.sendBreak()  # this is really slow on linux

    def startMessage(self):
        if self.prefixLength == 0 or self.sendFlush:
            self.flushComms()

    def stopMessage(self):
        pass

    # must be complete message in one call if prefixLength!=0
    def sendMessage(self, bytes):
        if not isinstance(bytes, str):
            bytes = "".join([chr(d) for d in bytes])
        bytes = self.addPrefix(bytes)
        if self.DEBUG:
            for d in bytes:
                print(">{:02x}".format(d), end=' ')
            print("")
        self.writeRaw(bytes)

    def writeRaw(self, b):
        self.serial.write(b)

    def skipBytes(self, length):
        self.skipByteCount += length  # dubiously threadsafe but eh

    def readBytes(self, length):
        reply = []
        for n in range(length):
            try:
                d = self.readQ.get(True, 1)
                reply.append(d)
            except queue.Empty:
                raise ReadTimeout("Read timeout from NX4, got {:d} of {:d}".format(len(reply), length))
        return reply

    def flushReply(self):
        self.readQ = queue.Queue()


# /////////////////////////////////////////////


class NX4Connector(object):

    # talks to the command processor module in the fpga

    def __init__(self, ioDevice, unitID=0):
        self.unitID = 0
        self.upperMemBits = 0xff
        self.ioDevice = ioDevice

        # remember not to trounce the default settings; could also just read them
        self.ioctl = NX4.DEFAULT_BAUD_MULTIPLIER << NX4.OpenNX4_REG_IOCTL_BIT_UART_BAUD_0
        self.sysctl = (1 << NX4.OpenNX4_REG_SYSCTL_BIT_MSG_LENGTH_PREFIX0) | (0 << NX4.OpenNX4_REG_SYSCTL_BIT_AUTO_BUFFER_FLIP) | (1 << NX4.OpenNX4_REG_SYSCTL_BIT_FB0_WRITE)

        self.mode = 0
        self.xlat = 0
        self.sclk = 0
        self.cpldTest = 0
        self.writeModuloLength = 0
        self.writeModuloModulo = 0

    def sendIOMessage(self, bytes):
        self.ioDevice.startMessage()
        self.ioDevice.sendMessage(bytes)
        self.ioDevice.stopMessage()

    def readBytes(self, length):
        return self.ioDevice.readBytes(length)

    def writeRegister(self, addr, values, skipReply=False):
        if not hasattr(values, '__iter__'):
            values = [values]
        bytes = [NX4.CP_CMD_MODE_REGISTERS | (self.unitID << NX4.CP_CMD_MODE_BIT_UNIT_ID) | (1 << NX4.CP_CMD_MODE_BIT_WRITE),
                 addr] + values
        self.sendIOMessage(bytes)
        if not skipReply:
            statusBytes = self.readBytes(len(values))
        else:
            self.ioDevice.skipBytes(len(values))
            statusBytes = None
        return statusBytes

    def writeFB(self, addr, values):
        if not hasattr(values, '__iter__'):
            values = [values]
        bytes = [NX4.CP_CMD_MODE_FB | (self.unitID << NX4.CP_CMD_MODE_BIT_UNIT_ID) | (1 << NX4.CP_CMD_MODE_BIT_WRITE),
                 addr & 0xff, addr >> 8] + values
        self.sendIOMessage(bytes)

    def writeFBRaw(self, addr, fbBytes):  # takes string of bytes instead of array of ints
        bytes = [NX4.CP_CMD_MODE_FB | (self.unitID << NX4.CP_CMD_MODE_BIT_UNIT_ID) | (1 << NX4.CP_CMD_MODE_BIT_WRITE),
                 addr & 0xff, addr >> 8]
        bytes = "".join([chr(d) for d in bytes])
        self.sendIOMessage(bytes + fbBytes)

    def writeIL(self, addr, values):
        cmode = NX4.CP_CMD_MODE_GAMMA
        isWrite = 1
        bytes = [cmode | (self.unitID << NX4.CP_CMD_MODE_BIT_UNIT_ID) | (isWrite << NX4.CP_CMD_MODE_BIT_WRITE),
                 addr & 0xff] + values
        self.sendIOMessage(bytes)

    def writeMem(self, addr, values, isFlash=1, isWrite=1):
        if not hasattr(values, '__iter__'):
            values = [values]
        self.setUpperMemAddress(addr)
        cmode = NX4.CP_CMD_MODE_FLASH if isFlash else NX4.CP_CMD_MODE_SRAM
        bytes = [cmode | (self.unitID << NX4.CP_CMD_MODE_BIT_UNIT_ID) | (isWrite << NX4.CP_CMD_MODE_BIT_WRITE),
                 addr & 0xff, (addr >> 8) & 0xff] + values
        self.sendIOMessage(bytes)

    def setUpperMemAddress(self, addr):
        umb = addr >> 16
        if umb == self.upperMemBits:
            return
        self.upperMemBits = umb
        self.writeRegister(NX4.OpenNX4_REG_MEM_UPPER_ADDR, umb)

    def readMem(self, addr, length, isFlash=1):
        values = [0 for d in range(length)]
        self.setUpperMemAddress(addr)
        # if length>256:
        #    self.setLengthPrefix(2)
        # same as a write but you send dummy values each of which triggers a read
        self.writeMem(addr, values, isFlash=isFlash, isWrite=0)
        return self.readBytes(length)

    def readRegister(self, addr, count=1):
        bytes = [NX4.CP_CMD_MODE_REGISTERS | (self.unitID << NX4.CP_CMD_MODE_BIT_UNIT_ID),
                 addr]
        for n in range(count):
            bytes.append(0)  # send dummy byte to trigger transmission of one
        self.sendIOMessage(bytes)
        return self.readBytes(1)[0]

    # def selectWriteFramebuffer(self,fbIndex):
    #    #self.writeRegister( NX4.OpenNX4_REG_SYSCTL , )

    def setLengthPrefix(self, prefixLength):
        # 0,1,2 byte length prefix
        lastPrefixLength = self.ioDevice.prefixLength
        mask = 3 << NX4.OpenNX4_REG_SYSCTL_BIT_MSG_LENGTH_PREFIX0
        self.sysctl = (self.sysctl & ~mask) | (prefixLength << NX4.OpenNX4_REG_SYSCTL_BIT_MSG_LENGTH_PREFIX0)
        self.writeRegister(NX4.OpenNX4_REG_SYSCTL, [self.sysctl])
        self.writeRegister(NX4.OpenNX4_REG_SYSCTL, [self.sysctl])

        # if lastPrefixLength:
        #     #need to flush last state of counter
        #     padding=chr(0)*(lastPrefixLength+1)
        #     print("{} {}".format(prefixLength, len(padding)))
        #     self.ioDevice.writeRaw(padding)
        #
        self.ioDevice.setLengthPrefix(prefixLength)

    def writeFramebuffer(self, addr, values):
        bytes = [NX4.CP_CMD_MODE_REGISTERS | (self.unitID << NX4.CP_CMD_MODE_BIT_UNIT_ID) | (1 << NX4.CP_CMD_MODE_BIT_WRITE),
                 addr] + values
        self.sendIOMessage(bytes)

    # ----------------------------------------------------


class NX4BitbangedI2C(object):
    DEBUG = False

    def i2cRead(self, i2cAddr, i2cRegAddr, length, address16Bit=False):
        i2Addr = [i2cRegAddr]
        if address16Bit:
            i2Addr = [i2cRegAddr >> 8, i2cRegAddr & 0xff]

        reply = self.i2cTransaction(i2cAddr, i2Addr, readLength=length)
        if reply == False:
            print("I2C NACK on address {:02x}".format(i2cAddr))
            return False
        return reply  # array of ints

    def i2cWrite(self, i2cAddr, i2cRegAddr, data, address16Bit=False):
        i2Addr = [i2cRegAddr]
        if address16Bit:
            i2Addr = [i2cRegAddr >> 8, i2cRegAddr & 0xff]
        data = i2Addr + data
        reply = self.i2cTransaction(i2cAddr, data, readLength=0)
        if reply == False:
            print("I2C NACK on address {:02x}".format(i2cAddr))
            return False

    def generateSCLSDA(self, scl, sda):
        mask = (1 << NX4.OpenNX4_REG_IOCTL_BIT_I2C_SCL) | (1 << NX4.OpenNX4_REG_IOCTL_BIT_I2C_SDA)
        self.nx4.ioctl = (self.nx4.ioctl & ~mask) | (scl << NX4.OpenNX4_REG_IOCTL_BIT_I2C_SCL) | (sda << NX4.OpenNX4_REG_IOCTL_BIT_I2C_SDA)
        return [self.nx4.ioctl]

    def i2cTxByte(self, byte, sendStart=False, sendStop=False):
        ioctlBytes = []
        bit = 0x80
        sda = 1

        if self.DEBUG:
            print("--- TX {:02x}".format(byte))
        # https://cdn.sparkfun.com/assets/6/4/7/1/e/51ae0000ce395f645d000000.png
        if sendStart:
            sda = 1
            scl = 1
            ioctlBytes += self.generateSCLSDA(scl, sda)

            sda = 0
            scl = 1  # start
            ioctlBytes += self.generateSCLSDA(scl, sda)

        while bit:
            scl = 0
            ioctlBytes += self.generateSCLSDA(scl, sda)
            sda = 1 if byte & bit else 0
            ioctlBytes += self.generateSCLSDA(scl, sda)
            scl = 1
            ioctlBytes += self.generateSCLSDA(scl, sda)

            bit >>= 1
        scl = 0
        sda = 1
        ioctlBytes += self.generateSCLSDA(scl, sda)
        scl = 1
        # sample ACK bit here
        samplePos = len(ioctlBytes)
        ioctlBytes += self.generateSCLSDA(scl, sda)
        scl = 0
        ioctlBytes += self.generateSCLSDA(scl, sda)

        if sendStop:
            sda = 0
            scl = 1
            ioctlBytes += self.generateSCLSDA(scl, sda)
            sda = 1
            scl = 1
            ioctlBytes += self.generateSCLSDA(scl, sda)

        replyData = self.nx4.writeRegister(NX4.OpenNX4_REG_IOCTL, ioctlBytes)

        if self.DEBUG:
            dp = 0
            for d in ioctlBytes:
                r = (replyData[dp] & (1 << NX4.OpenNX4_STATUS0_BIT_I2C_SDA)) == 1
                print("{:d}{:d} {:d} {}\t".format(d >> 3 & 1, d >> 4 & 1, r, "<" if dp == samplePos else ""))
                dp += 1
            print("{} {} {}".format(samplePos, len(ioctlBytes), len(replyData)))
        # check for ack
        sample = (replyData[samplePos] & (1 << NX4.OpenNX4_STATUS0_BIT_I2C_SDA)) == 0

        if self.isSimulation:
            return True

        return sample

    def i2cRxByte(self, sendNACK=0):
        ioctlBytes = []
        samplePositions = []
        bit = 0x80
        if self.DEBUG:
            print("---RX")

        sda = 1
        while bit:
            scl = 0
            ioctlBytes += self.generateSCLSDA(scl, sda)
            scl = 1
            ioctlBytes += self.generateSCLSDA(scl, sda)
            # sample SDA here
            samplePositions.append(len(ioctlBytes))
            bit >>= 1
        # send ack or stop
        scl = 0
        sda = sendNACK
        ioctlBytes += self.generateSCLSDA(scl, sda)
        scl = 1
        ioctlBytes += self.generateSCLSDA(scl, sda)
        scl = 0
        ioctlBytes += self.generateSCLSDA(scl, sda)

        # extra for debugging
        # if self.DEBUG:
        #    for n in range(5):
        #        ioctlBytes+=self.generateSCLSDA(scl,sda)

        # if we sent a NACK, send a stop as well
        if sendNACK:
            sda = 0
            scl = 1
            ioctlBytes += self.generateSCLSDA(scl, sda)
            sda = 1
            scl = 1
            ioctlBytes += self.generateSCLSDA(scl, sda)

        replyData = self.nx4.writeRegister(NX4.OpenNX4_REG_IOCTL, ioctlBytes)

        bit = 0x80
        byte = 0
        for samplePos in samplePositions:
            sample = replyData[samplePos] & (1 << NX4.OpenNX4_STATUS0_BIT_I2C_SDA)
            if sample:
                byte |= bit
            bit >>= 1

        if self.DEBUG:
            dp = 0
            for d in ioctlBytes:
                r = (replyData[dp] & (1 << NX4.OpenNX4_STATUS0_BIT_I2C_SDA)) == 1
                print("{:d}{:d} {:d} {}\t".format(d >> 3 & 1, d >> 4 & 1, r, "<" if dp in samplePositions else ""))
                dp += 1
            print("={:02x}".format(byte))

        return byte

    def i2cTransaction(self, i2cAddr, txData, readLength):
        reply = True
        self.setAddressModulo(1, 0)
        if not self.i2cTxByte(i2cAddr << 1, sendStart=True):
            # got a NACK
            return False
        if self.DEBUG:
            print("--- TX OK ON {:02x}".format(i2cAddr))
        dpos = 0
        for d in txData:
            isLastByte = (dpos == len(txData) - 1)
            sendStop = (isLastByte and readLength == 0)
            if not self.i2cTxByte(d, sendStop=sendStop):
                return False
            dpos += 1
        if readLength:
            if not self.i2cTxByte((i2cAddr << 1) | 1, sendStart=True):
                # got a NACK
                return False

            reply = []
            for r in range(readLength):
                isLastByte = (r == readLength - 1)
                reply.append(self.i2cRxByte(sendNACK=isLastByte))

        return reply


# /////////////////////////////////////////////

PIX = 1 << 0  # temp hacking constants for bitbang
SCLK = 1 << 3
XLAT = 1 << 2
MODE = 1 << 1
DC_WIDTH = 6
GS_WIDTH = 12


class OpenNX4(NX4BitbangedI2C):
    # https://cdn-shop.adafruit.com/datasheets/TSL2561.pdf
    I2C_ADDR_LIGHT_SENSOR = 0x39  #: LED Panel ambient light sensor
    # http://www.analog.com/media/en/technical-documentation/data-sheets/AD7416_7417_7418.pdf
    # https://github.com/rushup/Kitra530-kernel/blob/master/drivers/hwmon/ad7418.c
    I2C_ADDR_LED_TEMP = 0x48  #: LED Panel temperature sensor
    I2C_ADDR_CTRL_TEMP = 0x49  # ): Control Board temperature sensor
    # http://www.atmel.com/images/doc1116.pdf
    I2C_ADDR_LED_EEPROM = 0x50  # ): LED Panel EEPROM (512kbit/64kbyte)
    I2C_ADDR_CTRL_EEPROM = 0x51  # ): Control Board EEPROM (512kbit/64kbyte)

    def __init__(self, simulate=False):
        self.isSimulation = simulate
        if simulate:
            self.ioDevice = UARTSimulation({})
        else:
            self.ioDevice = UART({"port": DEFAULT_COM_PORT})
        self.ioDevice.openTransport()

        # eh just lazy
        self.ioDevice.setSimulationName(SIM_TEST_FILE)

        self.nx4 = NX4Connector(self.ioDevice, unitID=0)

        self.pixelWord = 0
        self.counter = 0

        # self.precalcScan()

        self.images = []

        self.testLEDs = [0 for d in range(3 * 32 * 36)]
        self.count = 100000
        if self.isSimulation:
            self.count = 20

    def close(self):
        # important if you're simulating, not so much for real
        self.ioDevice.closeTransport()

    def sleep(self, t):  # real sleep or dummy if simulating
        self.ioDevice.sleep(t)

    def selectFB(self, fbIndex):
        mask = (1 << NX4.OpenNX4_REG_SYSCTL_BIT_FB0_WRITE) | (1 << NX4.OpenNX4_REG_SYSCTL_BIT_FB1_WRITE)
        self.nx4.sysctl = (self.nx4.sysctl & ~mask) | (fbIndex << NX4.OpenNX4_REG_SYSCTL_BIT_FB0_WRITE)
        self.nx4.writeRegister(NX4.OpenNX4_REG_SYSCTL, [self.nx4.sysctl])

    # the "hello world" of the NX4
    def toggleRedLED(self):
        self.nx4.writeRegister(NX4.OpenNX4_REG_IOCTL, [self.nx4.ioctl])
        self.nx4.ioctl ^= (1 << NX4.OpenNX4_REG_IOCTL_BIT_RED_LED)

    # when writing to anything (registers,fb, sram etc)
    # you can have the dest address pointer jump forwards or backwards
    # after a certain number of writes, allowing you to send pixels to rectangular windows
    # or do a long string of register byte writes that loop over one or more registers
    def setAddressModulo(self, length, modulo=0):
        # print("SWM {} {}".format(length,modulo))
        if length != 1:
            modulo -= length
            modulo = modulo + 1
        else:
            modulo = 0  # odd special case here in the logic
        self.nx4.writeRegister(NX4.OpenNX4_REG_CMD_AUTOINC_LEN, length)
        self.nx4.writeRegister(NX4.OpenNX4_REG_CMD_AUTOINC_MODULO, modulo & 0xff)

    # can direct fb writes to fb0 (fbMask=1) or fb1 (=2) or both (=3)
    def setFBTarget(self, fbMask):
        mask = (1 << NX4.OpenNX4_REG_SYSCTL_BIT_FB1_WRITE) | (1 << NX4.OpenNX4_REG_SYSCTL_BIT_FB0_WRITE)
        self.nx4.sysctl = (self.nx4.sysctl & ~mask) | (fbMask << NX4.OpenNX4_REG_SYSCTL_BIT_FB0_WRITE)
        self.nx4.writeRegister(NX4.OpenNX4_REG_SYSCTL, self.nx4.sysctl)

    def testFlashPowerLED(self):
        # this is the 'hello world'
        # self.nx4.setLengthPrefix(2)
        for n in range(self.count):
            self.toggleRedLED()
            self.sleep(0.3)
            if self.ioDevice.stop:
                return

    # only for debug xilinx code
    def testWriteTestPixel(self):
        r = 1
        for n in range(self.count):
            print(r)
            self.nx4.writeRegister(NX4.OpenNX4_REG_TEST_PIXEL, r)
            self.sleep(0.1)
            self.nx4.writeRegister(NX4.OpenNX4_REG_TEST_PIXEL, 0)
            r <<= 1
            r &= 0xff
            if r == 0:
                r = 1
            self.toggleRedLED()
            self.sleep(0.25)

    def fbFill(self, rInc=0, gInc=0, bInc=0):
        width, height = 32, 36  # 36 #36
        fillRows = 6
        blank = []
        row = 0
        while row < height:
            blank = []
            b, g, r = 0, 0, 0
            for x in range(width):
                # b=255 if (x&31)<=(self.count&31) else 0
                # r=g=b=x<<3 #0xff
                # r=x # if not x&1 else 0 #0 #x10
                # g=x #0x10
                # b=x #x if x&1 else 0
                blank.append(r & 0xff)
                blank.append(g & 0xff)
                blank.append(b & 0xff)  # hardware shifts data out red,blue,green (green=last)
                r += rInc
                g += gInc
                b += bInc
            fbAddr = row * (32 * 3)
            # print(blank)
            # print("suf {:x}".format(fbAddr))
            self.nx4.writeFB(fbAddr, blank)
            row += 7 - fillRows
        # self.nx4.writeFB(0,blank)

    def clearFB(self):
        self.setFBTarget(3)  # write to both at the same time (may be useful? whatever it's free)
        self.setAddressModulo(0)
        self.nx4.setLengthPrefix(2)
        blank = [0 for n in range(32 * 36 * 3)]
        self.nx4.writeFB(0, blank)

        self.setFBTarget(1)

    # currently the way it's set up the base clk is 20mhz so;
    # pixel clk rate = 20mhz / (1<<pixelDivider)     (pwmDivider is same)
    # pwm should run at a multiple of the pclk, datasheet says max 30mhz for both clocks
    # pixel clock is limited by FPGA performance (and determines the row mux rate which is a visible artifact)
    def setPixelClock(self, pixelDivider=2, pwmDivider=0):
        value = (pixelDivider << NX4.OpenNX4_REG_DRIVECTL_BIT_PCLK_DIV0) | (pwmDivider << NX4.OpenNX4_REG_DRIVECTL_BIT_BCLK_DIV0)
        self.nx4.writeRegister(NX4.OpenNX4_REG_DRIVECTL, [value])

    # 6 bit value, be careful with the higher values if row scanning not enabled, you may
    # pop the leds!
    def loadDotCorrect(self, value):
        # loads the same dotcorrect to every driver
        self.nx4.writeRegister(NX4.OpenNX4_REG_DOT_CORRECT_TEST, [value])
        self.nx4.sysctl |= 1 << NX4.OpenNX4_REG_SYSCTL_BIT_UPDATE_DC
        self.nx4.writeRegister(NX4.OpenNX4_REG_SYSCTL, [self.nx4.sysctl])
        time.sleep(0.02)  # let it process a frame (UPDATE_DC latched at start of frame)
        # back to normal mode
        self.nx4.sysctl &= ~(1 << NX4.OpenNX4_REG_SYSCTL_BIT_UPDATE_DC)
        self.nx4.writeRegister(NX4.OpenNX4_REG_SYSCTL, [self.nx4.sysctl])

    def testSetupFill(self):
        self.nx4.setLengthPrefix(2)
        self.setAddressModulo(0)

        self.setFBTarget(1)
        self.fbFill(0, 0, 8)

        self.setFBTarget(2)
        self.fbFill(8, 0, 0)

        # display fb0 only
        self.nx4.writeRegister(NX4.OpenNX4_REG_FB0_INTENSITY, [0x0ff, 0])

    def testDotCorrectLoad(self):
        dc = 0
        for n in range(self.count):
            self.loadDotCorrect(dc & 63)
            dc += 1

    def setBufferBlend(self, blend0, blend1):
        self.nx4.writeRegister(NX4.OpenNX4_REG_FB0_INTENSITY, [blend0 & 0xff, blend1 & 0xff])

    def testFBBlending(self):
        fb0 = fb1 = 0

        self.setAddressModulo(0)
        wait = 1 / 60.0

        for n in range(256):
            self.setBufferBlend(n, 0)
            self.sleep(wait)

        self.sleep(2)
        for n in range(256):
            self.setBufferBlend(255 - n, 0)
            self.sleep(wait)

        for n in range(256):
            self.setBufferBlend(0, n)
            self.sleep(wait)
        self.sleep(2)

        for n in range(256):
            self.setBufferBlend(0, 255 - n)
            self.sleep(wait)

        self.sleep(2)

        for n in range(256):
            self.setBufferBlend(n, 0)
            self.sleep(wait)

        for n in range(256):  # blend between two
            self.setBufferBlend(255 - n, n)
            self.sleep(wait)

        for n in range(256):
            self.setBufferBlend(0, 255 - n)
            self.sleep(wait)

    def dumpMainFlash(self):
        self.setAddressModulo(0)
        faddr = 0
        flen = 2 * 1024 * 1024
        print("Dumping flash")
        maxSize = 252
        with open("flash_dump.bin", "wb") as f:
            while faddr < flen:
                print("Read {:08x}".format(faddr))
                blockSize = min(maxSize, flen - faddr)
                replyData = self.nx4.readMem(faddr, blockSize, isFlash=1)
                binary = "".join([chr(d) for d in replyData])
                f.write(binary)
                faddr += len(binary)
            # I2C_ADDR_LIGHT_SENSOR

    def dumpEEPROM(self, i2cAddr, length):
        self.setAddressModulo(0)
        faddr = 0
        binary = ""
        print("Dumping eeprom on address {:02x}".format(i2cAddr))
        maxReq = 240
        with open("eeprom_{:02x}_dump.bin".format(i2cAddr), "wb") as f:
            while faddr < length:
                blockSize = min(maxReq, length - faddr)
                print("Read {:08x}".format(faddr))
                replyData = self.i2cRead(i2cAddr, faddr, blockSize, address16Bit=True)
                binary = "".join([chr(d) for d in replyData])
                faddr += len(binary)
                f.write(binary)

    def dumpEEPROMs(self):
        i2cAddrs = [self.I2C_ADDR_LED_EEPROM, self.I2C_ADDR_CTRL_EEPROM]
        for i2cAddr in i2cAddrs:
            self.dumpEEPROM(i2cAddr, 0x10000)

    def testRWMemory(self, write=1):
        # SRAM R/W has some timing issues right now to fix, flash read is ok, not tried unlock+write yet
        fbAddr = 0x0
        flashWrite = False
        self.setAddressModulo(0)
        length = 14  # 64
        errors = 0
        for n in range(self.count):
            fbData = [(x + n) & 0xff for x in range(length)]
            print("write sram {}".format(errors))
            self.nx4.writeMem(fbAddr, fbData, isFlash=0)
            print("read sram {}".format(errors))
            replyData = self.nx4.readMem(fbAddr, len(fbData), isFlash=0)
            if replyData != fbData:
                print("Readback error")
                print("wr\t{}".format(fbData))
                print("rd\t{}".format(replyData))
                replyData = self.nx4.readMem(fbAddr, len(fbData), isFlash=0)
                if replyData != fbData:
                    print("rderr2\t{}".format(replyData))
                else:
                    print("2nd read ok!")
                errors += 1
            if flashWrite:
                print("write flash")
                self.nx4.writeMem(fbAddr, fbData, isFlash=1)
            # print("read flash")
            replyData = self.nx4.readMem(fbAddr, 128, isFlash=1)
            print(replyData)
            return
            # self.toggleRedLED()
            # self.sleep(0.1)

    # write the 8b->12b pixel conversion table; this boots  up with sensible values already
    def testILWrite(self):
        ilAddr = 0x00
        ilData = []
        # this write isn't quite right in the verilog
        for ilCount in range(256):
            ilValue = ilCount << 4  # crappy test; this isn't as nice as the default (cie curve) lookup
            ilValue = 0xfff if ilValue != 0 else 0
            ilData.append(ilValue & 0xff)
            ilData.append(ilValue >> 8)
        # self.setAddressModulo(0)
        self.nx4.setLengthPrefix(2)
        self.nx4.writeIL(0, ilData)

    def displayImage(self, index, x, y):
        imgW, imgH, pixels = self.images[index]
        width, height = 32, 36
        fb = []
        fbAddr = (x * 3) + (y * height * 3)  # x,y not really useful, doesn't clip image yet
        for h in range(height):
            src = imgW * 3 * h
            for w in range(width * 3):
                fb.append(pixels[src + w])  # rgb
        self.nx4.setLengthPrefix(2)
        self.nx4.writeFB(fbAddr, fb)

    def testImageDisplay(self):
        if not self.images:
            self.loadImage("pacman.png")
            self.loadImage("nyan_cat.png")

        self.setFBTarget(1)  # write to both at the same time (may be useful? whatever it's free)
        y = 0
        x = 0
        self.displayImage(0, x, y)
        self.setFBTarget(2)  # write to both at the same time (may be useful? whatever it's free)
        y = 0
        x = 0
        self.displayImage(1, x, y)

    def testI2C(self):
        tests = [self.I2C_ADDR_LIGHT_SENSOR, self.I2C_ADDR_LED_TEMP, self.I2C_ADDR_CTRL_TEMP, self.I2C_ADDR_LED_EEPROM, self.I2C_ADDR_CTRL_EEPROM]
        length = 2
        for i2cAddr in tests:
            for i2cRegAddr in range(2):
                print("Read I2C {:02x} reg {:02x}".format(i2cAddr, i2cRegAddr))
                print("={:02x}".format(self.i2cRead(i2cAddr, i2cRegAddr, 1)[0]))
                # self.setAddressModulo(0)  #i2c leaves write modulo wacky
            self.toggleRedLED()

    # not working yet
    def readLightSensor(self):
        # https://cdn-shop.adafruit.com/datasheets/TSL2561.pdf
        i2cAddr = self.I2C_ADDR_LIGHT_SENSOR

        i2cRegAddr = 0 | 0x80
        controlReg = 3  # 3=power on
        if self.i2cWrite(i2cAddr, i2cRegAddr, [controlReg]):
            print("Light sensor not responding")
            return
        # read it back to check
        checkControl = self.i2cRead(i2cAddr, i2cRegAddr, 1)[0]
        print("rbc {}".format(checkControl))

        i2cRegAddr = 0xa | 0x80  # id register
        partId = self.i2cRead(i2cAddr, i2cRegAddr, 1)[0]
        print("Part number= {:02x}".format(partId))

        i2cRegAddr = 1 | 0x80
        timingReg = 0x02  # 2=default; controls gain, integration time
        partId = self.i2cWrite(i2cAddr, i2cRegAddr, [timingReg])
        while True:
            i2cRegAddr = 0x0c | 0x80
            adcReg = self.i2cRead(i2cAddr, i2cRegAddr, 4)
            ch0 = adcReg[0] << 8 | adcReg[1]
            ch1 = adcReg[2] << 8 | adcReg[3]
            print("{} {}".format(ch0, ch1))

    def setBB(self, bbBit, bbVal, noWrite=False):
        self.bbState = (self.bbState & ~bbBit) | (bbVal * bbBit)
        if not noWrite:
            self.nx4.writeRegister(NX4.OpenNX4_REG_BITBANG_TEST, [self.bbState])

    # baud stuff
    def calcClockSettings(self):
        baseClk = 40000000
        base = int(baseClk / 115200)
        for div in range(8):
            actualBaud = baseClk / (base >> div)
            print("{} {}".format(div, actualBaud))

    def testVideoPlayback(self, sourceFile, fps=25):
        vs = VideoSource(tileW=32, tileH=36, tileArrayW=1, tileArrayH=1, tileIndexX=0, tileIndexY=0)
        # vs=VideoSource(tileW=32,tileH=36,tileArrayW=3,tileArrayH=3,tileIndexX=1,tileIndexY=1)

        vs.start(sourceFile, fps=fps)
        fbTarget = 0
        frameCount = 0
        debug = False
        while True:
            frame = vs.nextFrame()

            playTime = frameCount / fps
            print("{:02d}:{:02d}:{:02d} - {:06d}".format(int(playTime / 60), int(playTime % 60), (playTime % 1) % 100, frameCount))
            frameCount += 1

            # for now, until we get row scan working, duplicate each row 6 times, effectively lowering the vertical res to 6 pixels :-)
            dupeRows = False
            if dupeRows:
                frameOut = ""
                height = 36
                row = 0
                while row < height:
                    rowData = frame[row * 32 * 3:(row + 1) * 32 * 3]
                    frameOut += rowData * 6
                    row += 6
                # endhack

            # it's not very complicated...
            self.setFBTarget(1 << fbTarget)
            frame = [ord(d) for d in frame]
            self.nx4.writeFB(0, frame)

            blend0 = 0xff if fbTarget == 0 else 0
            blend1 = 0xff - blend0
            self.setBufferBlend(blend0, blend1)

            fbTarget ^= 1

            if debug:
                for n in range(16):
                    m = n * 3
                    print("{:02x}{:02x}{:02x}".format(ord(frame[m]), ord(frame[m + 1]), ord(frame[m + 2])), end=' ')
                print("")

    def fiddlewithCPLD(self, scan):
        """
        `define  OpenNX4_REG_CPLD_BITBANG_BIT_PIN2 0        
        `define  OpenNX4_REG_CPLD_BITBANG_BIT_PIN3 1        
        `define  OpenNX4_REG_CPLD_BITBANG_BIT_PIN8 2        
        `define  OpenNX4_REG_CPLD_BITBANG_BIT_PIN41 3       
        `define  OpenNX4_REG_CPLD_BITBANG_BIT_PIN42 4       
        `define  OpenNX4_REG_CPLD_BITBANG_BIT_PIN43 5       
        `define  OpenNX4_REG_CPLD_BITBANG_BIT_PIN44 6       
        """
        # f=random.randint(0,255)
        self.nx4.cpldTest = (self.nx4.cpldTest + 1)  # f #^=1 #^=(1<<NX4.OpenNX4_REG_CPLD_BITBANG_BIT_PIN2)
        print("{:02x} ".format(self.nx4.cpldTest), end=' ')
        status = self.nx4.writeRegister(NX4.OpenNX4_REG_CPLD_BITBANG_TEST, [self.nx4.cpldTest & 0xff])
        print(" = st {:02x}".format(status[0] >> 3))

    # obsolete stuff that bit-bangs the led ports for initial testing
    """
    def shiftPix(self,width,value,repeats=1,latch=False):
        for r in range(repeats):
            for n in range(width):
                bit=(value>>((width-1)-n))&1
                self.setBB(PIX,bit)
                self.setBB(SCLK,1)
                self.setBB(SCLK,0,noWrite=True)
        if latch:
            self.setBB(XLAT,1)
            self.setBB(XLAT,0)


    def writePixelRegs(self):
        lDriver=((self.pixelWord>>6)&63) |  (self.nx4.mode<<NX4.OpenNX4_REG_DRIVERL_BITBANG_BIT_MODE)
        rDriver=(self.pixelWord&63) | (self.nx4.xlat<<NX4.OpenNX4_REG_DRIVERR_BITBANG_BIT_XLAT) | (self.nx4.sclk<<NX4.OpenNX4_REG_DRIVERR_BITBANG_BIT_SCLK)
        self.pixelRegsDump.append(lDriver)
        self.pixelRegsDump.append(rDriver)

    def flushPixelRegs(self):
        print("Flushing {}".format(len(self.pixelRegsDump))
        #the target modulo is set so writing two values loops forever over the two bitbang destination registers
        self.nx4.writeRegister(NX4.OpenNX4_REG_DRIVERL_BITBANG_TEST,self.pixelRegsDump,skipReply=True)
        self.pixelRegsDump=[]

    def bitbangDotCorrect(self,dotCorrect):
        self.pixelRegsDump=[]
        flushThreshold=240
        self.setAddressModulo(2,0) #set it to loop over the two bitbang registers
        self.nx4.xlat=0
        self.nx4.mode=1
        for rgb in range(3):
            for ledIndex in range(16):
                for bit in range(6):
                    word=0
                    if dotCorrect & (1<<(5-bit)):
                        word|=(1<<12)-1

                    self.pixelWord=word
                    self.nx4.sclk=1-self.nx4.sclk  #there is a small speedup hack in the xilinx BITBANG mode that strobes SCLK each time you change the value (so you don't have to send both edges)
                    self.writePixelRegs()

                if len(self.pixelRegsDump)>=flushThreshold:
                    self.flushPixelRegs()
                if self.ioDevice.stop:
                    return
        self.nx4.xlat=1
        self.writePixelRegs()
        self.nx4.xlat=0
        self.writePixelRegs()
        
        self.flushPixelRegs()
        
        self.nx4.mode=0
    
    #speedup for bitbanging
    def precalcScan(self):
        scan=[]
        offset=0
        for rgb in range(3):
            for ledIndex in range(16):
                for bit in range(12):
                    for pixel in range(12):
                        if pixel<6:
                            pixelOffset=((6*32*3)*pixel)+offset
                        else:
                            pixelOffset=(((6*32*3)*(pixel-6))+(16*3))+offset
                        ledID=(ledIndex*3)+rgb+pixelOffset
                        scan.append([ledID,(1<<(11-bit)),(1<<pixel)])
        self.precalcedScan=scan


    def bitbangWritePixels(self,leds,scan):
        self.pixelRegsDump=[]
        offset=scan*(32*3)
        self.nx4.xlat=0
        self.nx4.mode=0
        flushThreshold=240
        self.setAddressModulo(2,0) #set it to loop over the two bitbang registers
      
        wcount=0
        word=0
        for s in self.precalcedScan:
            ledid,mask,result=s
            if leds[ledid+offset] & mask:
                word|=result
            wcount+=1
            if wcount==12:
                self.pixelWord=word
                self.nx4.sclk=1-self.nx4.sclk  #there is a small speedup hack in the xilinx BITBANG mode that strobes SCLK each time you change the value (so you don't have to send both edges)
                self.writePixelRegs()
                wcount=0
                word=0
                if len(self.pixelRegsDump)>=flushThreshold:
                    self.flushPixelRegs()
                if self.ioDevice.stop:
                    return
            

        self.nx4.xlat=1
        self.writePixelRegs()
        self.nx4.xlat=0
        self.writePixelRegs()

        self.flushPixelRegs()
        
        self.fiddlewithCPLD(scan)
                    
        
    def shiftInRows(self,leds,width=GS_WIDTH):
        self.nx4.writeRegister(NX4.OpenNX4_REG_BITBANG_TEST,[self.bbState])
                
        #slice pixels for main display 16xR,16xG,16xB layout
        for rgb in range(3):
            for ledIndex in range(16):
                word=0
                led=testLEDs[(ledIndex*3)+rgb]
                for bit in range(12):
                    if led & (1<<(11-bit)):
                        self.setBB(PIX,1)
                    else:
                        self.setBB(PIX,0)
                    self.setBB(SCLK,1)
                    self.setBB(SCLK,0,noWrite=True)
    
                
    def testLoadLEDs(self):
        self.bbState=0
        testLEDs=[0 for d in range(3*16*2*6)]
        pixelCount=len(testLEDs)
        dotCorrectValue=0x03
        cpTest=0
        while True:
            self.setBB(XLAT,1)
            self.setBB(XLAT,0)
            #load gs
            self.setBB(MODE,1)
            self.shiftPix(DC_WIDTH,dotCorrectValue,repeats=pixelCount,latch=True)
            
            self.setBB(MODE,0)
            rgbPixel=0
            tledCount=2
            cpldTest=0
            while True:
                rgbPixel^=4095
                #testLEDs[2]^=4095 #rgbPixel
                #testLEDs[2]^=4095 #rgbPixel
                #2nd to 10th inclusive are the 3 text pixels
                testLEDs[tledCount]=rgbPixel
                if rgbPixel==0:
                    tledCount=(tledCount+1)%(16*3)
                
                #slice pixels for main display 16xR,16xG,16xB layout
                for rgb in range(3):
                    for ledIndex in range(16):
                        word=0
                        led=testLEDs[(ledIndex*3)+rgb]
                        for bit in range(12):
                            if led & (1<<(11-bit)):
                                self.setBB(PIX,1)
                            else:
                                self.setBB(PIX,0)
                            self.setBB(SCLK,1)
                            self.setBB(SCLK,0,noWrite=True)




                #for t in testLEDs:
                #    self.shiftPix(GS_WIDTH,t)
                self.setBB(XLAT,1)
                self.setBB(XLAT,0)

                cpldTest=(cpldTest+1)&127;
                print "%02x" % cpldTest
                self.nx4.writeRegister(NX4.OpenNX4_REG_CPLD_BITBANG_TEST, [cpldTest])
    
    def bitBangLEDs(self):
        #set it to use 1-byte length prefixes to delineate commands
        pixelPos=0
        nextRow=(6*32*3)
        for n in range(self.count):
            self.bitbangDotCorrect(DOT_CORRECT_DEFAULT)
    
            for r in range(6):
                self.testLEDs[pixelPos+(nextRow*r)]=0
            pixelPos=(pixelPos+3)%(3*32)
            self.testLEDs[pixelPos]=0xfff
            for r in range(6):
                self.testLEDs[pixelPos+(nextRow*r)]=0xfff
            print "--- Frame",n,pixelPos
            for scan in range(1):
                ts=time.time()
                self.bitbangWritePixels(self.testLEDs,scan)
                #print "%.4f" % (time.time()-ts)
                if self.ioDevice.stop:
                    return
    """

    def loadImage(self, filename):
        if not HAS_PYGAME:
            raise Exception("Need to install pygame (e.g. 'apt-get install python-pygame', also available on windows)")
        image = pygame.image.load(filename)
        print("Loaded {} : {:d}x{:d}".format(filename, image.get_width(), image.get_height()))
        imageID = len(self.images)
        self.images.append((image.get_width(), image.get_height(), [ord(d) for d in pygame.image.tostring(image, "RGB")]))
        return imageID


# ////////////////////////////////////////////////
""" 
todo cmdline args
DEFAULT_SERIAL_PORT="/dev/ttyUSB0"

        parser = argparse.ArgumentParser(description='Tantos comms tool')
        parser.add_argument('--port', metavar='COMxx', type=str,default=DEFAULT_SERIAL_PORT,
                           help="Specify main message port; COM port connected to device (e.g. 'COM40' or '/dev/ttyUSB0')")
        parser.add_argument('--transprot', type=str, 
                           help='UART on DEBUG_RX from nuvoton (Test device only) ')
        parser.add_argument('--op', type=str,help="packageFirmware, generateSD, tester, generateSerials"
                            )
        try:
            args = parser.parse_args()
        except Exception,ex:
            print 'Error parsing arguments'
            for k in sys.argv:
                print k
            args=[]

"""

test = "uart"
simulate = False
if len(sys.argv) > 1:
    simulate = (sys.argv[1] == "test")

"""
if test=="spi":
    print "SPI test"
    t=SPITest().generateTest("spi_tester_gen.v")
"""

if test == "uart":
    o = OpenNX4(simulate=simulate)

    brightness = 5  # goes up to 63.. BE CAREFUL b/c we haven't got row scanning running, keep this low (say <20) or you may overheat the single row LEDs
    # o.testILWrite()
    o.setPixelClock(2, 0)
    o.loadDotCorrect(brightness)  # load all pixels w/same dotcorrect value
    o.clearFB()

    # this is so slow you can see the rows scanning, is kinda cool/useful
    # o.setPixelClock(9,0)

    while not o.ioDevice.stop:

        try:
            # o.testFlashPowerLED()   #'hello world!'
            # o.testWriteFB()
            # o.testSetupFill()
            o.testImageDisplay()
            o.testFBBlending()

            # anything ffmpeg will play..
            # o.testVideoPlayback("../../media/test.mkv",fps=23.976215)
            # o.ioDevice.stop=True
            # o.testDotCorrectLoad()

            # this is a great speed for actual use, 5mhz pixel clock
            # which is only 695us for a whole frame (1438fps)

            # o.testWriteTestPixel()
            # o.testI2C()

            # o.testRWMemory()
            # o.dumpMainFlash()
            # o.dumpEEPROMs()
            # o.readLightSensor()
            # o.testLoadLEDs()
            # o.bitBangLEDs()
            o.count += 1
        except ReadTimeout:
            print(">> Read timeout <<")

    print("Closing")
    o.close()
